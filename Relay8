#include <WiFi.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>
#include <BeeNeXT.h>

// ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• WiFi ‡πÅ‡∏•‡∏∞ MQTT
const char* ssid = "nubia";      
const char* password = "123456789";    
const char* mqtt_server = "3.25.216.166";
const int mqtt_port = 1883;
const char* mqtt_username = "wasuMQTT";
const char* mqtt_password = "123456789Za";

WiFiClient espClient;
PubSubClient client(espClient);

const char* cabinetId = "cab_tok_001";
char topic_control[50];
DynamicJsonDocument doc(8192);  // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏ô‡∏≤‡∏î‡πÄ‡∏õ‡πá‡∏ô 8192 ‡πÄ‡∏ú‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏°‡∏≤‡∏Å

// ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ç‡∏≤ GPIO ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ESP32-S3-DevKitC-1
// ‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏à‡∏£‡∏¥‡∏á‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏
// *** ‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏: ESP32-S3 ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏° relay ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á ‡πÅ‡∏ï‡πà‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ú‡πà‡∏≤‡∏ô UART ‡πÑ‡∏õ‡∏¢‡∏±‡∏á Mega ***
// GPIO pins ‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏µ‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏≠‡∏∑‡πà‡∏ô‡πÜ (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ) ‡∏´‡∏£‡∏∑‡∏≠‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡∏ô‡∏≤‡∏Ñ‡∏ï
int ecPumpPin = 4;         // ‡∏™‡∏≥‡∏£‡∏≠‡∏á (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô)
int phPumpPin = 5;         // ‡∏™‡∏≥‡∏£‡∏≠‡∏á (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô)
int agitatorPumpPin = 6;   // ‡∏™‡∏≥‡∏£‡∏≠‡∏á (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô)
int fan_internal_pin = 7;  // ‡∏™‡∏≥‡∏£‡∏≠‡∏á (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô)
int fan_external_pin = 8;  // ‡∏™‡∏≥‡∏£‡∏≠‡∏á (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô)
int light_pin = 14;        // ‡∏™‡∏≥‡∏£‡∏≠‡∏á (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô)
int co2_pin = 19;          // ‡∏™‡∏≥‡∏£‡∏≠‡∏á (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô)
int cooling_pump_pin = 21; // ‡∏™‡∏≥‡∏£‡∏≠‡∏á (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô)

// ‡∏Ç‡∏≤ Serial2 ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö Arduino Mega (‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏)
// ESP32-S3 GPIO17 (TX2) -> Arduino Mega RX2 (‡∏Ç‡∏≤ 17)
// ESP32-S3 GPIO18 (RX2) -> Arduino Mega TX2 (‡∏Ç‡∏≤ 16)
#define RXD2 18  // GPIO18 ‡∏ö‡∏ô ESP32-S3 ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Arduino Mega TX2 (‡∏Ç‡∏≤ 16)
#define TXD2 17  // GPIO17 ‡∏ö‡∏ô ESP32-S3 ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏õ Arduino Mega RX2 (‡∏Ç‡∏≤ 17)

// ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ß‡∏•‡∏≤‡πÅ‡∏ö‡∏ö non-blocking
unsigned long currentMillis;  // ‡πÄ‡∏Å‡πá‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡πÉ‡∏ô‡∏Ç‡∏ì‡∏∞‡∏ô‡∏µ‡πâ
unsigned long mqttReconnectInterval = 2000;  // ‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏´‡∏ô‡πà‡∏ß‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏≠‡∏á‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÉ‡∏´‡∏°‡πà (‡πÉ‡∏ô‡∏°‡∏¥‡∏•‡∏•‡∏¥‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)

// ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏±‡πä‡∏°‡∏Å‡∏ß‡∏ô‡∏™‡∏≤‡∏£
unsigned long agitatorPumpStartTime = 0;  // ‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á‡∏õ‡∏±‡πä‡∏°‡∏Å‡∏ß‡∏ô‡∏™‡∏≤‡∏£
unsigned long agitatorPumpDelay = 3600000;  // ‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏õ‡∏±‡πä‡∏°‡∏à‡∏∞‡∏ó‡∏≥‡∏á‡∏≤‡∏ô (1 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á ‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô)
bool agitatorPumpRunning = false;  // ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á‡∏õ‡∏±‡πä‡∏°‡∏Å‡∏ß‡∏ô‡∏™‡∏≤‡∏£

// ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏±‡πä‡∏° EC
unsigned long ecPumpStartTime = 0;  // ‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á‡∏õ‡∏±‡πä‡∏° EC
unsigned long ecPumpDuration = 0;   // ‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏õ‡∏±‡πä‡∏° EC ‡∏à‡∏∞‡∏ó‡∏≥‡∏á‡∏≤‡∏ô (‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≤‡∏Å‡∏Ñ‡πà‡∏≤‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î * kofec)
bool ecPumpRunning = false;         // ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á‡∏õ‡∏±‡πä‡∏° EC

// ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏±‡πä‡∏° PH
unsigned long phPumpStartTime = 0;  // ‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á‡∏õ‡∏±‡πä‡∏° PH
unsigned long phPumpDuration = 0;   // ‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏õ‡∏±‡πä‡∏° PH ‡∏à‡∏∞‡∏ó‡∏≥‡∏á‡∏≤‡∏ô (‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≤‡∏Å‡∏Ñ‡πà‡∏≤‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î * kofph)
bool phPumpRunning = false;         // ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á‡∏õ‡∏±‡πä‡∏° PH

bool receivedData = false; // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å MQTT ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á

// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡πà‡∏≤ timestamp
unsigned long unixTimestamp = 0;
unsigned long timeOnly = 0;

// ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡πà‡∏≤‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå (‡∏à‡∏≤‡∏Å‡∏ö‡∏≠‡∏£‡πå‡∏î Arduino Mega)
int co2Value = 0;
float airHumidity = 0.0;
float airTemperature = 0.0;
float waterPH = 0.0;
float ecValue = 0.0;
float waterTemperature = 0.0;
unsigned long lightValue = 0;
int waterLevel = 0;

// ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å PZEM-004T
float voltage = 0.0;
float current = 0.0;
float power = 0.0;
float energy = 0.0;
float frequency = 0.0;
float pf = 0.0;

bool hasNewSensorData = false;  // ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà‡∏à‡∏≤‡∏Å Arduino Mega ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà

//‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏≠‡∏±‡∏ï‡∏£‡∏≤‡∏Å‡∏≤‡∏£‡πÑ‡∏´‡∏•‡∏Ç‡∏≠‡∏á‡∏ô‡πâ‡∏≥
float flowRate1 = 0.0, flowRate2 = 0.0, flowRate3 = 0.0;
float totalLiters1 = 0.0, totalLiters2 = 0.0, totalLiters3 = 0.0;

// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏™‡∏∑‡πà‡∏≠‡∏™‡∏≤‡∏£‡∏Å‡∏±‡∏ö Mega
unsigned long lastMegaComm = 0;
bool megaConnected = false;

// ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Arduino Mega
unsigned long lastMegaDataCheckTime = 0;
const unsigned long megaDataCheckInterval = 10; // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏∏‡∏Å 10ms (‡πÄ‡∏£‡πá‡∏ß‡∏°‡∏≤‡∏Å)

// ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• MQTT
unsigned long lastSensorPublishTime = 0;
const unsigned long sensorPublishInterval = 200; // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏∏‡∏Å 200ms (5 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ï‡πà‡∏≠‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)

// ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏•‡πá‡∏≠‡∏Å‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞
bool debugEnabled = true;  // ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏î‡∏µ‡∏ö‡∏±‡∏Å
unsigned long lastStatusPrint = 0;
const unsigned long statusPrintInterval = 30000;  // ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ó‡∏∏‡∏Å 30 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ

// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏£‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
unsigned long lastDataRequestTime = 0;
const unsigned long dataRequestInterval = 500;  // ‡∏£‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏∏‡∏Å 500ms (‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô)

// ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö BeeNeXT display update
unsigned long lastBeeNeXTUpdateTime = 0;
const unsigned long beeNeXTUpdateInterval = 2000;  // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏à‡∏≠‡∏ó‡∏∏‡∏Å 2 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
bool beeNeXTConnected = false;

// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡πá‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå
bool fan_internal_state = false;
bool fan_external_state = false;
bool light_state = false;
bool co2_state = false;
bool cooling_pump_state = false;

// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡πá‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏à‡∏≤‡∏Å MQTT
struct ControlSettings {
    // Internal Fan Settings
    bool internal_fan_enabled = false;
    int internal_fan_on_hour = 8;
    int internal_fan_off_hour = 20;
    unsigned long internal_fan_delay_on = 1800;  // ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
    unsigned long internal_fan_delay_off = 900;  // ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
    
    // External Fan Settings
    bool external_fan_enabled = false;
    float external_fan_on_temp = 28.0;
    float external_fan_off_temp = 25.0;
    
    // Light Settings
    bool light_enabled = false;
    int light_on_hour = 12;
    int light_off_hour = 13;
    unsigned long light_on_when = 5000;   // lux
    unsigned long light_off_when = 15000; // lux
    
    // CO2 Settings
    bool co2_enabled = false;
    int co2_on_hour = 6;
    int co2_off_hour = 18;
    int co2_on_ppm = 400;
    int co2_off_ppm = 1200;
    
    // EC/PH Settings
    bool ec_ph_enabled = false;
    unsigned long ec_ph_time_cycle = 28800; // ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ (8 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á)
    float target_ec = 2.2;
    float kof_ec = 10.0;
    float target_ph = 6.0;
    float kof_ph = 1.0;
    unsigned long agitator_delay = 3600000; // ‡∏°‡∏¥‡∏•‡∏•‡∏¥‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
    unsigned long last_ec_ph_cycle = 0;
    
    // Cooling Settings
    bool cooling_enabled = false;
    float cooling_on_temp = 25.0;
    float cooling_off_temp = 22.0;
    
    // Circulation Pump Settings
    bool circulation_enabled = false;
    
    // Water Level Check Settings
    bool water_level_check_enabled = false;
} controlSettings;

// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡πÅ‡∏ö‡∏ö cycle
unsigned long lastControlExecutionTime = 0;
const unsigned long controlExecutionInterval = 1000; // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏ó‡∏∏‡∏Å 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á
void executeControlLogic() {
    if (millis() - lastControlExecutionTime < controlExecutionInterval) {
        return; // ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏ñ‡∏∂‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
    }
    
    lastControlExecutionTime = millis();
    
    if (unixTimestamp == 0) {
        return; // ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö timestamp
    }
    
    unsigned long currentHour = (unixTimestamp / 3600) % 24;
    unsigned long currenttimeonlyhour = timeOnly;
    String relayCommand = "RELAY:00000000";
    bool needToSendCommand = false;

    // 1. Internal Fan Control (K5 - ‡∏û‡∏±‡∏î‡∏•‡∏°‡∏†‡∏≤‡∏¢‡πÉ‡∏ô‡∏ï‡∏π‡πâ)
    if (controlSettings.internal_fan_enabled) {
        Serial.println("Internal fan enabled");
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÉ‡∏ô‡∏ß‡∏±‡∏ô
        bool timeInRange = false;
        if (controlSettings.internal_fan_on_hour < controlSettings.internal_fan_off_hour) {
            timeInRange = (currenttimeonlyhour >= controlSettings.internal_fan_on_hour && currenttimeonlyhour < controlSettings.internal_fan_off_hour);
        } else {
            timeInRange = (currenttimeonlyhour >= controlSettings.internal_fan_on_hour || currenttimeonlyhour < controlSettings.internal_fan_off_hour);
        }
        
        if (timeInRange) {
            // ‡∏£‡∏∞‡∏ö‡∏ö cycling ‡πÅ‡∏ö‡∏ö non-blocking ‡πÉ‡∏ä‡πâ unixTimestamp
            static unsigned long lastFanCycleTimestamp = 0;
            static bool fanCycleState = false; // false = OFF period, true = ON period
            
            unsigned long currentTimestamp = unixTimestamp;
            unsigned long cycleInterval;
            
            if (fanCycleState) {
                // ‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡∏û‡∏±‡∏î‡∏•‡∏°
                cycleInterval = controlSettings.internal_fan_delay_on; // ‡πÉ‡∏ä‡πâ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
                relayCommand.setCharAt(6 + 4, '1'); // K5 ON
                
                if (currentTimestamp - lastFanCycleTimestamp >= cycleInterval) {
                    fanCycleState = false; // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏ä‡πà‡∏ß‡∏á‡∏õ‡∏¥‡∏î
                    lastFanCycleTimestamp = currentTimestamp;
                    Serial.println("üåÄ Internal fan cycle: ON period completed, switching to OFF");
                }
            } else {
                // ‡∏ä‡πà‡∏ß‡∏á‡∏õ‡∏¥‡∏î‡∏û‡∏±‡∏î‡∏•‡∏°
                cycleInterval = controlSettings.internal_fan_delay_off; // ‡πÉ‡∏ä‡πâ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
                // K5 OFF (‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏ã‡πá‡∏ï ‡πÄ‡∏û‡∏£‡∏≤‡∏∞ relayCommand ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÄ‡∏õ‡πá‡∏ô 0)
                
                if (currentTimestamp - lastFanCycleTimestamp >= cycleInterval) {
                    fanCycleState = true; // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏õ‡∏¥‡∏î
                    lastFanCycleTimestamp = currentTimestamp;
                    Serial.println("üåÄ Internal fan cycle: OFF period completed, switching to ON");
                }
            }
            
            // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞
            if (fanCycleState != fan_internal_state) {
                fan_internal_state = fanCycleState;
                needToSendCommand = true;
                Serial.println("üåÄ Internal fan (K5) " + String(fanCycleState ? "ON" : "OFF") + " - Natural wind simulation");
            }
            
        } else {
            // ‡∏ô‡∏≠‡∏Å‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏≥‡∏á‡∏≤‡∏ô - ‡∏õ‡∏¥‡∏î‡∏û‡∏±‡∏î‡∏•‡∏°
            if (fan_internal_state) {
                fan_internal_state = false;
                needToSendCommand = true;
                Serial.println("üåÄ Internal fan OFF (K5) - Outside time range");
            }
        }
    }
    
    // 2. External Fan Control (K3 - ‡∏û‡∏±‡∏î‡∏•‡∏°‡∏£‡∏∞‡∏ö‡∏≤‡∏¢‡∏≠‡∏≤‡∏Å‡∏≤‡∏®)
    if (controlSettings.external_fan_enabled) {
        Serial.println("External fan enabled");
        bool shouldBeOn = false;
        if (airTemperature >= controlSettings.external_fan_on_temp) {
            shouldBeOn = true;
        } else if (airTemperature <= controlSettings.external_fan_off_temp) {
            shouldBeOn = false;
        } else {
            shouldBeOn = fan_external_state; // Keep current state (hysteresis)
        }
        
        if (shouldBeOn != fan_external_state) {
            fan_external_state = shouldBeOn;
            needToSendCommand = true;
            Serial.println("üå™Ô∏è External fan " + String(shouldBeOn ? "ON" : "OFF") + " (K3) - Temp: " + String(airTemperature) + "¬∞C");
        }
        
        if (shouldBeOn) {
            relayCommand.setCharAt(6 + 2, '1'); // K3 - ‡∏û‡∏±‡∏î‡∏•‡∏°‡∏£‡∏∞‡∏ö‡∏≤‡∏¢‡∏≠‡∏≤‡∏Å‡∏≤‡∏®
        }
    }
    
    // 3. Light_co2 Control K1
    if (controlSettings.light_enabled) {
        // Serial.println("Light enabled");
        Serial.println("Light on hour: " + String(controlSettings.light_on_hour));
        Serial.println("Light off hour: " + String(controlSettings.light_off_hour));
        Serial.println("Current hour: " + String(currenttimeonlyhour));

        bool timeCondition = false;
        if (controlSettings.light_on_hour < controlSettings.light_off_hour) {
            // Serial.println("Light on hour < off hour");
            timeCondition = (currenttimeonlyhour >= controlSettings.light_on_hour && currenttimeonlyhour < controlSettings.light_off_hour);
        } else {
            // Serial.println("Light on hour > off hour");
            timeCondition = (currenttimeonlyhour >= controlSettings.light_on_hour || currenttimeonlyhour < controlSettings.light_off_hour);
        }
        // Serial.println("light" + String(lightValue));
        bool lightCondition = (lightValue < controlSettings.light_on_when);
        bool shouldBeOn = timeCondition && lightCondition;
        
        Serial.println("Time condition: " + String(timeCondition));
        Serial.println("Light condition: " + String(lightCondition));
        Serial.println("Should be ON: " + String(shouldBeOn));
        if (lightValue > 1000 || !timeCondition) {
            shouldBeOn = false;
        }
        
        if (shouldBeOn != light_state) {
            light_state = shouldBeOn;
            needToSendCommand = true;
            Serial.println("üí° Light " + String(shouldBeOn ? "ON" : "OFF") + " - Time: " + String(currentHour) + "h, Light: " + String(lightValue) + " lux");
        }
        
        if (shouldBeOn) {
            Serial.println("Light should be on");
            relayCommand.setCharAt(6 + 0, '1'); // K1
        }
    }
    
    // 4. CO2 (light_co2) Control
    if (controlSettings.co2_enabled) {
        Serial.println("CO2 enabled");
        bool timeCondition = false;
        // if (controlSettings.co2_on_hour < controlSettings.co2_off_hour) {
        //     timeCondition = (currentHour >= controlSettings.co2_on_hour && currentHour < controlSettings.co2_off_hour);
        // } else {
        //     timeCondition = (currentHour >= controlSettings.co2_on_hour || currentHour < controlSettings.co2_off_hour);
        // }
        
        bool co2Condition = (co2Value < controlSettings.co2_on_ppm);
        bool fanNotRunning = !fan_external_state;
        // bool shouldBeOn = timeCondition && co2Condition && fanNotRunning;
        bool shouldBeOn = co2Condition; 
        
        if (co2Value > controlSettings.co2_off_ppm) {
            shouldBeOn = false;
        }
        
        if (shouldBeOn != co2_state) {
            co2_state = shouldBeOn;
            needToSendCommand = true;
            Serial.println("üå± CO2 " + String(shouldBeOn ? "ON" : "OFF") + " - CO2: " + String(co2Value) + " ppm, Fan: " + String(fan_external_state ? "ON" : "OFF"));
        }
        
        if (shouldBeOn) {
            relayCommand.setCharAt(6 + 7, '1'); // K8
        }
    }
    
    // 5. EC/PH Control (Using Unix Timestamp - Real Time)
    if (controlSettings.ec_ph_enabled) {
        
        // ‡πÉ‡∏ä‡πâ Unix Timestamp ‡πÅ‡∏ó‡∏ô millis() ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥
        static unsigned long lastECPHCycle = 0;
        static bool ecphCycleActive = false;
        
        unsigned long cycleInterval = controlSettings.ec_ph_time_cycle; // ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ (‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏õ‡∏•‡∏á)
        Serial.println("Cycle interval: " + String(cycleInterval));
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ñ‡∏∂‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏° cycle ‡πÉ‡∏´‡∏°‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà (‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡∏à‡∏£‡∏¥‡∏á)
        if (!ecphCycleActive && unixTimestamp > 0 && (unixTimestamp - lastECPHCycle >= cycleInterval)) {
            ecphCycleActive = true;
            lastECPHCycle = unixTimestamp;
            
            Serial.println("EC/PH enabled");
            Serial.println("Cycle time: " + String(controlSettings.ec_ph_time_cycle) + " seconds");
            Serial.println("üß™ EC/PH Cycle Started (Real Time) - Target EC: " + String(controlSettings.target_ec) + ", Target PH: " + String(controlSettings.target_ph));
            Serial.println("üïê Current Unix Time: " + String(unixTimestamp) + ", Last Cycle: " + String(lastECPHCycle));
            
            // ‡πÄ‡∏õ‡∏¥‡∏î‡∏õ‡∏±‡πä‡∏°‡∏ß‡∏±‡∏î (K4)
            // relayCommand.setCharAt(6 + 3, '1');
            
            // === ‡∏ä‡∏∏‡∏î‡∏à‡πà‡∏≤‡∏¢‡∏õ‡∏∏‡πã‡∏¢ A, B (EC Control) ===
            // E_error = EC - EC‡∏ó‡∏µ‡πà‡∏ß‡∏±‡∏î‡πÑ‡∏î‡πâ
            float E_error = controlSettings.target_ec - ecValue;
            Serial.println("üìä EC Analysis: Target=" + String(controlSettings.target_ec) + ", Current=" + String(ecValue) + ", Error=" + String(E_error));
           
            Serial.println("E_error: " + String(E_error));
            Serial.println("controlSettings.target_ec: " + String(controlSettings.target_ec));
            Serial.println("ecValue: " + String(ecValue));

            if (E_error > 0) {
                // ‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ï‡∏¥‡∏°‡∏™‡∏≤‡∏£ = E_error * KofEC
                unsigned long ecPumpDuration = (unsigned long)(E_error * controlSettings.kof_ec * 1000);
                
                // ‡πÄ‡∏ï‡∏¥‡∏°‡∏™‡∏≤‡∏£‡∏ï‡∏≤‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô -> ‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ï‡∏¥‡∏°‡∏™‡∏≤‡∏£
                relayCommand.setCharAt(6 + 6, '1'); // K7 - ‡∏ä‡∏∏‡∏î‡∏à‡πà‡∏≤‡∏¢‡∏õ‡∏∏‡πã‡∏¢ A,B
                ecPumpRunning = true;
                ecPumpStartTime = millis();
                ecPumpDuration = ecPumpDuration;
                
                String ecPumpCommand = "PUMP_TIMING:EC," + String(ecPumpDuration);
                Serial2.println(ecPumpCommand);
                Serial.println("üß™ ‡∏ä‡∏∏‡∏î‡∏à‡πà‡∏≤‡∏¢‡∏õ‡∏∏‡πã‡∏¢ A,B: EC Error=" + String(E_error) + ", Duration=" + String(ecPumpDuration) + " ms");
            } else {
                Serial.println("‚úÖ EC Level OK - No fertilizer needed");
            }
            
            // === ‡∏ä‡∏∏‡∏î‡∏à‡πà‡∏≤‡∏¢‡∏Å‡∏£‡∏î‡πÑ‡∏ô‡∏ï‡∏£‡∏¥‡∏Å (PH Control) ===
            // P_error = PH - PH‡∏ó‡∏µ‡πà‡∏ß‡∏±‡∏î‡πÑ‡∏î‡πâ
            float P_error = controlSettings.target_ph - waterPH;
            Serial.println("üìä PH Analysis: Target=" + String(controlSettings.target_ph) + ", Current=" + String(waterPH) + ", Error=" + String(P_error));
            
            if (P_error != 0) {
                // ‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ï‡∏¥‡∏°‡∏™‡∏≤‡∏£ = P_error * KofPH
                unsigned long phPumpDuration = (unsigned long)(abs(P_error) * controlSettings.kof_ph * 1000);
                
                // ‡πÄ‡∏ï‡∏¥‡∏°‡∏™‡∏≤‡∏£‡∏ï‡∏≤‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô -> ‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ï‡∏¥‡∏°‡∏™‡∏≤‡∏£
                relayCommand.setCharAt(6 + 5, '1'); // K6 - ‡∏ä‡∏∏‡∏î‡∏à‡πà‡∏≤‡∏¢‡∏Å‡∏£‡∏î‡πÑ‡∏ô‡∏ï‡∏£‡∏¥‡∏Å
                phPumpRunning = true;
                phPumpStartTime = millis();
                phPumpDuration = phPumpDuration;
                
                String phPumpCommand = "PUMP_TIMING:PH," + String(phPumpDuration);
                Serial2.println(phPumpCommand);
                Serial.println("üß™ ‡∏ä‡∏∏‡∏î‡∏à‡πà‡∏≤‡∏¢‡∏Å‡∏£‡∏î‡πÑ‡∏ô‡∏ï‡∏£‡∏¥‡∏Å: PH Error=" + String(P_error) + ", Duration=" + String(phPumpDuration) + " ms");
            } else {
                Serial.println("‚úÖ PH Level OK - No acid needed");
            }
            
            needToSendCommand = true;
            
            // ‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á relay
            if (needToSendCommand) {
                Serial2.println(relayCommand);
                Serial.println("üîÑ Sent EC/PH control command: " + relayCommand);
            }
            
            // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏£‡∏≠ cycle ‡∏ñ‡∏±‡∏î‡πÑ‡∏õ (‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡∏à‡∏£‡∏¥‡∏á)
            unsigned long nextCycleTime = unixTimestamp + cycleInterval;
            Serial.println("üîÑ EC/PH cycle completed, next cycle in " + String(controlSettings.ec_ph_time_cycle) + " seconds");
            Serial.println("‚è∞ Next cycle at Unix time: " + String(nextCycleTime));
            Serial.println("‚è≥ System continues running normally while waiting...");
            
            // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏≠ cycle ‡∏ñ‡∏±‡∏î‡πÑ‡∏õ
            ecphCycleActive = false;
        }
    }
    
    // 6. Cooling Control
    if (controlSettings.cooling_enabled) {

        bool shouldBeOn = false;
        if (waterTemperature >= controlSettings.cooling_on_temp) {
            // Serial.println("Cooling on");
            shouldBeOn = true;
        } else if (waterTemperature <= controlSettings.cooling_off_temp) {
            // Serial.println("Cooling off");
            shouldBeOn = false;
        } else {
            // Serial.println("Cooling off");
            shouldBeOn = cooling_pump_state; // Keep current state (hysteresis)
        }
        
        if (shouldBeOn != cooling_pump_state) {
            // Serial.println("Cooling state changed");
            cooling_pump_state = shouldBeOn;
            needToSendCommand = true;
            Serial.println("‚ùÑÔ∏è Cooling " + String(shouldBeOn ? "ON" : "OFF") + " - Water temp: " + String(waterTemperature) + "¬∞C");
        }
        
        if (shouldBeOn) {
            // Serial.println("Cooling should be on");
            relayCommand.setCharAt(6 + 1, '1'); // K2
        }
    }
    
    // 7. Circulation Pump (Always ON when enabled)
    if (controlSettings.circulation_enabled) {
        Serial.println("Circulation pump enabled");
        static unsigned long lastFlowCheck = 0;
        if (millis() - lastFlowCheck >= 10000) { // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ó‡∏∏‡∏Å 10 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
            lastFlowCheck = millis();
            
            if (flowRate1 <= 0.1) {
                Serial.println("‚ö†Ô∏è WARNING: Low flow rate! " + String(flowRate1) + " L/min");
                String alertCommand = "FLOW_ALERT:LOW_FLOW," + String(flowRate1);
                Serial2.println(alertCommand);
            }
            
            String pumpCommand = "CIRCULATION_PUMP:ON";
            Serial2.println(pumpCommand);
        }
    }
    
    // 8. Water Level Check
    if (controlSettings.water_level_check_enabled) {
        Serial.println("Water level check enabled");
        static unsigned long lastWaterLevelCheck = 0;
        if (millis() - lastWaterLevelCheck >= 30000) { // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ó‡∏∏‡∏Å 30 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
            lastWaterLevelCheck = millis();
            
            if (waterLevel < 20) {
                Serial.println("‚ö†Ô∏è WARNING: Low water level! " + String(waterLevel) + "%");
                String alertCommand = "WATER_ALERT:LOW_LEVEL," + String(waterLevel);
                Serial2.println(alertCommand);
            } else if (waterLevel > 90) {
                Serial.println("‚ö†Ô∏è WARNING: High water level! " + String(waterLevel) + "%");
                String alertCommand = "WATER_ALERT:HIGH_LEVEL," + String(waterLevel);
                Serial2.println(alertCommand);
            }
        }
    }
    
    // ‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á relay ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á
    if (needToSendCommand) {
        Serial2.println(relayCommand);
        Serial.println("üîÑ Sent continuous control command: " + relayCommand);
    }
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á MQTT
void updateControlSettings(JsonDocument& doc) {
    String command = doc["command"].as<String>();
    
    if (command == "Internal_cooling_fan") {
        controlSettings.internal_fan_enabled = true;
        controlSettings.internal_fan_on_hour = doc["value"]["on"];
        controlSettings.internal_fan_off_hour = doc["value"]["off"];
        controlSettings.internal_fan_delay_on = doc["value"]["delay_on"];
        controlSettings.internal_fan_delay_off = doc["value"]["delay_off"];
        Serial.println("‚úÖ Updated Internal Fan Settings - ON: " + String(controlSettings.internal_fan_on_hour) + "h, OFF: " + String(controlSettings.internal_fan_off_hour) + "h");
    }
     if (command == "External_cooling_fan") {
        controlSettings.external_fan_enabled = true;
        controlSettings.external_fan_on_temp = doc["value"]["on_temperature_when"];
        controlSettings.external_fan_off_temp = doc["value"]["off_temperature_when"];
        Serial.println("‚úÖ Updated External Fan Settings - ON: " + String(controlSettings.external_fan_on_temp) + "¬∞C, OFF: " + String(controlSettings.external_fan_off_temp) + "¬∞C");
    }
    if (command == "light_control") {
        controlSettings.light_enabled = true;
        controlSettings.light_on_hour = doc["value"]["on"];
        controlSettings.light_off_hour = doc["value"]["off"];
        controlSettings.light_on_when = doc["value"]["light_on_when"];
        controlSettings.light_off_when = doc["value"]["light_off_when"];
        Serial.println("‚úÖ Updated Light Settings - ON: " + String(controlSettings.light_on_hour) + "h, OFF: " + String(controlSettings.light_off_hour) + "h");
    }
    //  if (command == "co2_control") {
    //     controlSettings.co2_enabled = true;
    //     controlSettings.co2_on_hour = doc["value"]["on"];
    //     controlSettings.co2_off_hour = doc["value"]["off"];
    //     controlSettings.co2_on_ppm = doc["value"]["co2_on"];
    //     controlSettings.co2_off_ppm = doc["value"]["co2_off"];
    //     Serial.println("‚úÖ Updated CO2 Settings - ON: " + String(controlSettings.co2_on_hour) + "h, OFF: " + String(controlSettings.co2_off_hour) + "h");
    // }
     if (command == "EC_PH") {
        controlSettings.ec_ph_enabled = true;
        if (doc["value"].containsKey("time_cycle")) {
            controlSettings.ec_ph_time_cycle = doc["value"]["time_cycle"];
        }
        controlSettings.target_ec = doc["value"]["EC"];
        controlSettings.kof_ec = doc["value"]["KofEC"];
        controlSettings.target_ph = doc["value"]["PH"];
        controlSettings.kof_ph = doc["value"]["KofPH"];
        controlSettings.agitator_delay = doc["value"]["AgitatorPump_delay"];
        Serial.println("‚úÖ Updated EC/PH Settings - EC: " + String(controlSettings.target_ec) + ", PH: " + String(controlSettings.target_ph));
    }
     if (command == "Cooling") {
        controlSettings.cooling_enabled = true;
        controlSettings.cooling_on_temp = doc["value"]["on_cooling_when"];
        controlSettings.cooling_off_temp = doc["value"]["off_cooling_when"];
        Serial.println("‚úÖ Updated Cooling Settings - ON: " + String(controlSettings.cooling_on_temp) + "¬∞C, OFF: " + String(controlSettings.cooling_off_temp) + "¬∞C");
    }
    if (command == "circulation_pump") {
        controlSettings.circulation_enabled = true;
        Serial.println("‚úÖ Enabled Circulation Pump Control");
    }
    if (command == "water_level_check") {
        controlSettings.water_level_check_enabled = true;
        Serial.println("‚úÖ Enabled Water Level Monitoring");
    }
    if (command == "light_co2") {
        // ‡∏£‡∏ß‡∏°‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÑ‡∏ü‡πÅ‡∏•‡∏∞ CO2
        controlSettings.light_enabled = true;
        controlSettings.co2_enabled = true;
        controlSettings.light_on_hour = doc["value"]["on"];
        controlSettings.light_off_hour = doc["value"]["off"];
        controlSettings.co2_on_hour = doc["value"]["on"];
        controlSettings.co2_off_hour = doc["value"]["off"];
        controlSettings.co2_on_ppm = doc["value"]["co2_on"];//‡πÉ‡∏ä‡πâ
        controlSettings.co2_off_ppm = doc["value"]["co2_off"];//‡πÉ‡∏ä‡πâ
        controlSettings.light_on_when = 10000;  // ‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
        controlSettings.light_off_when = 15000; // ‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
        Serial.println("‚úÖ Updated Light+CO2 Settings - ON: " + String(controlSettings.light_on_hour) + "h, OFF: " + String(controlSettings.light_off_hour) + "h");
    }
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡πÅ‡∏ö‡∏ö manual
void controlDevice(int pin, bool state, String deviceName) {
    digitalWrite(pin, state ? HIGH : LOW);
    if (debugEnabled) {
        Serial.println(deviceName + (state ? " ON" : " OFF"));
    }
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
void updateDeviceStates() {
    controlDevice(fan_internal_pin, fan_internal_state, "Internal Fan");
    controlDevice(fan_external_pin, fan_external_state, "External Fan");
    controlDevice(light_pin, light_state, "Light");
    controlDevice(co2_pin, co2_state, "CO2");
    controlDevice(cooling_pump_pin, cooling_pump_state, "Cooling Pump");
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
void resetAllDevices() {
    fan_internal_state = false;
    fan_external_state = false;
    light_state = false;
    co2_state = false;
    cooling_pump_state = false;
    updateDeviceStates();
    if (debugEnabled) {
        Serial.println("üîÑ All devices reset to OFF state");
    }
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏î‡∏µ‡∏ö‡∏±‡∏Å (‡∏¢‡πâ‡∏≤‡∏¢‡∏°‡∏≤‡πÑ‡∏ß‡πâ‡∏Å‡πà‡∏≠‡∏ô executeControlLogic)
void debugPrint(String message) {
  if (debugEnabled) {
    Serial.println(message);
  }
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MQTT
void connectToMQTT() {
    // ‡∏•‡∏≠‡∏á‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
    while (!client.connected()) {
        Serial.println("Connecting to MQTT...");
        // ‡∏™‡∏£‡πâ‡∏≤‡∏á client ID ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ô
        String clientId = "ESP32S3Client-";
        clientId += String(random(0xffff), HEX);
        
        if (client.connect(clientId.c_str(), mqtt_username, mqtt_password)) {
            Serial.println("‚úÖ Connected to MQTT!");
            
            // Subscribe ‡πÑ‡∏õ‡∏¢‡∏±‡∏á topics ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
            sprintf(topic_control, "cabinets/%s/control", cabinetId);
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£ subscribe topic control ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
            if (client.subscribe(topic_control)) {
                Serial.println("üì° Subscribed to control topic: " + String(topic_control));
            }
            
            // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£ subscribe ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö timesync
            if (client.subscribe("timesync2")) {
                Serial.println("üì° Subscribed to: timesync2");
            }
            
            // Subscribe ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö BeeNeXT (‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏•‡∏±‡∏ö‡∏à‡∏≤‡∏Å‡∏à‡∏≠)
            char beeNeXTDataTopic[64];
            sprintf(beeNeXTDataTopic, "cabinets/%s/data", cabinetId);
            if (client.subscribe(beeNeXTDataTopic)) {
                Serial.println("üì∫ Subscribed to BeeNeXT data topic: " + String(beeNeXTDataTopic));
            }
            
        } else {
            Serial.println("‚ö†Ô∏è Failed to connect to MQTT, rc=" + String(client.state()));
            Serial.println("Retrying in 2 seconds...");
            delay(2000);
        }
    }
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• JSON ‡πÑ‡∏õ‡∏¢‡∏±‡∏á MQTT (‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤ float)
void publishSensorData(const char* sensorName, float value) {
    // ‡∏•‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡πà‡∏≤ 0 ‡∏≠‡∏≠‡∏Å
    if (!client.connected() || unixTimestamp == 0) {
        return;
    }
    
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á JSON document
    StaticJsonDocument<256> jsonDoc;
    
    // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≤‡∏°‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
    jsonDoc["cabinet_id"] = cabinetId;
    jsonDoc["sensor"] = sensorName;
    jsonDoc["value"] = value;
    jsonDoc["timestamp"] = unixTimestamp;
    
    // ‡πÅ‡∏õ‡∏•‡∏á JSON ‡πÄ‡∏õ‡πá‡∏ô string
    char jsonBuffer[256];
    serializeJson(jsonDoc, jsonBuffer);
    
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á topic ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    char topic[50];
    sprintf(topic, "cabinets/%s/data", cabinetId);
    
    // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏õ‡∏¢‡∏±‡∏á MQTT server
    client.publish(topic, jsonBuffer);
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• JSON ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô Object
void publishSensorDataObject(const char* sensorName, const JsonObject& valueObj) {
    if (!client.connected() || unixTimestamp == 0) {
        return;
    }
    
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á JSON document
    StaticJsonDocument<256> jsonDoc;
    
    // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≤‡∏°‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
    jsonDoc["cabinet_id"] = cabinetId;
    jsonDoc["sensor"] = sensorName;
    jsonDoc["value"] = valueObj;
    jsonDoc["timestamp"] = unixTimestamp;
    
    // ‡πÅ‡∏õ‡∏•‡∏á JSON ‡πÄ‡∏õ‡πá‡∏ô string
    char jsonBuffer[256];
    serializeJson(jsonDoc, jsonBuffer);
    
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á topic ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    char topic[50];
    sprintf(topic, "cabinets/%s/data", cabinetId);
    
    // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏õ‡∏¢‡∏±‡∏á MQTT server
    client.publish(topic, jsonBuffer);
}
// ‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á Arduino Mega
void sendJsonCommandToMega(JsonDocument& doc) {
  String output;
  serializeJson(doc, output);
  Serial2.println(output);
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á JSON ‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á String ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö relay
String convertJsonToRelayCommand(JsonDocument& doc) {
    String command = doc["command"].as<String>();
    
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á relay ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô (‡∏õ‡∏¥‡∏î‡∏ó‡∏∏‡∏Å relay)
    // ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö: "RELAY:12345678" ‡πÇ‡∏î‡∏¢ 1=‡πÄ‡∏õ‡∏¥‡∏î, 0=‡∏õ‡∏¥‡∏î
    // ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á: // === Relay8 Control (D26-D33) ===
// #define RELAY_IN1    26  // K1 - ‡∏ä‡∏∏‡∏î‡∏´‡∏•‡∏≠‡∏î‡πÑ‡∏ü
// #define RELAY_IN2    27  // K2 - ‡∏ä‡∏∏‡∏î‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏¢‡πá‡∏ô
// #define RELAY_IN3    28  // K3 - External Fan Control
// #define RELAY_IN4    29  // K4 - ‡∏õ‡∏±‡πä‡∏°‡∏™‡∏≤‡∏£‡∏•‡∏∞‡∏•‡∏≤‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô‡∏£‡∏≤‡∏á‡∏õ‡∏•‡∏π‡∏Å
// #define RELAY_IN5    30  // K5 - Internal Fan Control 
// #define RELAY_IN6    31  // K6 - ‡∏ä‡∏∏‡∏î‡∏à‡πà‡∏≤‡∏¢‡∏Å‡∏£‡∏î‡πÑ‡∏ô‡∏ï‡∏£‡∏¥‡∏Å,‡∏õ‡∏±‡πä‡∏°‡∏Å‡∏ß‡∏ô‡∏™‡∏≤‡∏£‡∏•‡∏∞‡∏•‡∏≤‡∏¢
// #define RELAY_IN7    32  // K7 - ‡∏ä‡∏∏‡∏î‡∏à‡πà‡∏≤‡∏¢‡∏™‡∏≤‡∏£‡∏•‡∏∞‡∏•‡∏≤‡∏¢ A,B
// #define RELAY_IN8    33  // K8 - ‡∏ä‡∏∏‡∏î‡∏à‡πà‡∏≤‡∏¢ CO2

    String relayCommand = "RELAY:00000000";
    bool commandProcessed = false;
    
    // 1. ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏û‡∏±‡∏î‡∏•‡∏°‡∏†‡∏≤‡∏¢‡πÉ‡∏ô‡∏ï‡∏π‡πâ (Internal Cooling Fan) -> K5 (‡∏û‡∏±‡∏î‡∏•‡∏°‡∏†‡∏≤‡∏¢‡πÉ‡∏ô‡∏ï‡∏π‡πâ)
    // ‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°/‡∏´‡∏¢‡∏∏‡∏î ‡πÅ‡∏•‡∏∞‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏±‡∏ô
    if (command == "Internal_cooling_fan") {
        commandProcessed = true;
        if (!doc.containsKey("value") || !doc["value"].containsKey("on") || 
            !doc["value"].containsKey("off") || !doc["value"].containsKey("delay_on") || 
            !doc["value"].containsKey("delay_off")) {
            Serial.println("‚ö†Ô∏è Missing required parameters for Internal_cooling_fan");
            return "";
        }
        
        int on = doc["value"]["on"];
        int off = doc["value"]["off"];
        unsigned long delay_on = doc["value"]["delay_on"];  // ‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏õ‡∏¥‡∏î (‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)
        unsigned long delay_off = doc["value"]["delay_off"]; // ‡πÄ‡∏ß‡∏•‡∏≤‡∏õ‡∏¥‡∏î (‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)
        unsigned long currentHour = (unixTimestamp / 3600) % 24;

        Serial.println("Internal cooling fan control (K5 - ‡∏û‡∏±‡∏î‡∏•‡∏°‡∏†‡∏≤‡∏¢‡πÉ‡∏ô‡∏ï‡∏π‡πâ)");
        Serial.println("ON time: " + String(on) + ", OFF time: " + String(off));
        Serial.println("Delay ON: " + String(delay_on) + "s, Delay OFF: " + String(delay_off) + "s");
        Serial.println("Current hour: " + String(currentHour));

        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
        bool shouldBeOn = false;
        if (on < off) {
            shouldBeOn = (currentHour >= on && currentHour < off);
        } else {
            shouldBeOn = (currentHour >= on || currentHour < off);
        }
        
        if (shouldBeOn) {
            // ‡πÄ‡∏õ‡∏¥‡∏î‡∏û‡∏±‡∏î‡∏•‡∏°‡∏†‡∏≤‡∏¢‡πÉ‡∏ô (K5 - ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà 4)
            relayCommand.setCharAt(6 + 4, '1');
            fan_internal_state = true;
            Serial.println("üåÄ Internal fan ON (K5) - Natural wind simulation");
            
            // ‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÅ‡∏ö‡∏ö‡∏™‡∏•‡∏±‡∏ö‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î
            String fanCycleCommand = "FAN_CYCLE:INTERNAL," + String(delay_on) + "," + String(delay_off);
            Serial2.println(fanCycleCommand);
            Serial.println("Sent fan cycle command: " + fanCycleCommand);
        } else {
            fan_internal_state = false;
            Serial.println("üåÄ Internal fan OFF (K5)");
        }
    }
    
    // 2. ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏û‡∏±‡∏î‡∏•‡∏°‡∏£‡∏∞‡∏ö‡∏≤‡∏¢‡∏≠‡∏≤‡∏Å‡∏≤‡∏® (External Cooling Fan) -> K3 (‡∏û‡∏±‡∏î‡∏•‡∏°‡∏£‡∏∞‡∏ö‡∏≤‡∏¢‡∏≠‡∏≤‡∏Å‡∏≤‡∏®)
    // ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏≠‡∏∏‡∏ì‡∏´‡∏†‡∏π‡∏°‡∏¥‡∏≠‡∏≤‡∏Å‡∏≤‡∏®
    if (command == "External_cooling_fan") {
        commandProcessed = true;
        if (!doc.containsKey("value") || !doc["value"].containsKey("on_temperature_when") || 
            !doc["value"].containsKey("off_temperature_when")) {
            Serial.println("‚ö†Ô∏è Missing required parameters for External_cooling_fan");
            return "";
        }
        
        float on_temp = doc["value"]["on_temperature_when"];
        float off_temp = doc["value"]["off_temperature_when"];

        Serial.println("External cooling fan control (K3 - ‡∏û‡∏±‡∏î‡∏•‡∏°‡∏£‡∏∞‡∏ö‡∏≤‡∏¢‡∏≠‡∏≤‡∏Å‡∏≤‡∏®)");
        Serial.println("ON when temp >= " + String(on_temp) + "¬∞C, OFF when temp <= " + String(off_temp) + "¬∞C");
        Serial.println("Current temperature: " + String(airTemperature) + "¬∞C");

        if (airTemperature >= on_temp) {
            // ‡πÄ‡∏õ‡∏¥‡∏î‡∏û‡∏±‡∏î‡∏•‡∏°‡∏£‡∏∞‡∏ö‡∏≤‡∏¢‡∏≠‡∏≤‡∏Å‡∏≤‡∏® (K3 - ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà 2)
            relayCommand.setCharAt(6 + 2, '1');
            fan_external_state = true;
            Serial.println("üå™Ô∏è External fan ON (K3) - Temperature control");
        } else if (airTemperature <= off_temp) {
            fan_external_state = false;
            Serial.println("üå™Ô∏è External fan OFF (K3)");
        }
    }
    
    // 3. ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏´‡∏•‡∏≠‡∏î‡πÑ‡∏ü (Light) -> K1 (‡∏ä‡∏∏‡∏î‡∏´‡∏•‡∏≠‡∏î‡πÑ‡∏ü)
    // ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î ‡πÅ‡∏•‡∏∞‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ß‡πà‡∏≤‡∏á
    if (command == "light_control") {
        commandProcessed = true;
        if (!doc.containsKey("value") || !doc["value"].containsKey("on") || 
            !doc["value"].containsKey("off") || !doc["value"].containsKey("light_on_when") || 
            !doc["value"].containsKey("light_off_when")) {
            Serial.println("‚ö†Ô∏è Missing required parameters for light_control");
            return "";
        }
        
        int light_on_hour = doc["value"]["on"];
        int light_off_hour = doc["value"]["off"];
        unsigned long light_on_when = doc["value"]["light_on_when"];   // ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ß‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤‡∏Ñ‡πà‡∏≤‡∏ô‡∏µ‡πâ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡∏¥‡∏î
        unsigned long light_off_when = doc["value"]["light_off_when"]; // ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ß‡πà‡∏≤‡∏á‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤‡∏Ñ‡πà‡∏≤‡∏ô‡∏µ‡πâ‡πÉ‡∏´‡πâ‡∏õ‡∏¥‡∏î
        unsigned long currentHour = (unixTimestamp / 3600) % 24;

        Serial.println("Light control (K1 - ‡∏ä‡∏∏‡∏î‡∏´‡∏•‡∏≠‡∏î‡πÑ‡∏ü)");
        Serial.println("Time ON: " + String(light_on_hour) + ", Time OFF: " + String(light_off_hour));
        Serial.println("Light ON when < " + String(light_on_when) + " lux, OFF when > " + String(light_off_when) + " lux");
        Serial.println("Current hour: " + String(currentHour) + ", Current light: " + String(lightValue) + " lux");
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÄ‡∏ß‡∏•‡∏≤
        bool timeCondition = false;
        if (light_on_hour < light_off_hour) {
            timeCondition = (currentHour >= light_on_hour && currentHour < light_off_hour);
        } else {
            timeCondition = (currentHour >= light_on_hour || currentHour < light_off_hour);
        }
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ß‡πà‡∏≤‡∏á
        bool lightCondition = (lightValue < light_on_when);
        
        if (timeCondition && lightCondition) {
            // ‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏ü (K1 - ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà 0)
            relayCommand.setCharAt(6 + 0, '1');
            light_state = true;
            Serial.println("Turn ON light (K1) - Time & Light conditions met");
        } else if (lightValue > light_off_when || !timeCondition) {
            light_state = false;
            Serial.println("Turn OFF light (K1) - Conditions not met");
        }
    }
    
    // 4. ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏à‡πà‡∏≤‡∏¢ CO2 -> K8 (‡∏ä‡∏∏‡∏î‡∏à‡πà‡∏≤‡∏¢ CO2)
    // ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î ‡πÅ‡∏•‡∏∞‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏õ‡∏£‡∏¥‡∏°‡∏≤‡∏ì CO2
    // CO2 ‡∏à‡∏∞‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏¥‡∏î‡∏ñ‡πâ‡∏≤‡∏û‡∏±‡∏î‡∏•‡∏°‡∏£‡∏∞‡∏ö‡∏≤‡∏¢‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏¢‡∏π‡πà
    if (command == "co2_control") {
        commandProcessed = true;
        if (!doc.containsKey("value") || !doc["value"].containsKey("on") || 
            !doc["value"].containsKey("off") || !doc["value"].containsKey("co2_on") || 
            !doc["value"].containsKey("co2_off")) {
            Serial.println("‚ö†Ô∏è Missing required parameters for co2_control");
            return "";
        }
        
        int co2_on_hour = doc["value"]["on"];
        int co2_off_hour = doc["value"]["off"];
        int co2_on = doc["value"]["co2_on"];   // CO2 ‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤‡∏Ñ‡πà‡∏≤‡∏ô‡∏µ‡πâ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡∏¥‡∏î
        int co2_off = doc["value"]["co2_off"]; // CO2 ‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤‡∏Ñ‡πà‡∏≤‡∏ô‡∏µ‡πâ‡πÉ‡∏´‡πâ‡∏õ‡∏¥‡∏î
        unsigned long currentHour = (unixTimestamp / 3600) % 24;

        Serial.println("CO2 control (K8 - ‡∏ä‡∏∏‡∏î‡∏à‡πà‡∏≤‡∏¢ CO2)");
        Serial.println("Time ON: " + String(co2_on_hour) + ", Time OFF: " + String(co2_off_hour));
        Serial.println("CO2 ON when < " + String(co2_on) + " ppm, OFF when > " + String(co2_off) + " ppm");
        Serial.println("Current hour: " + String(currentHour) + ", Current CO2: " + String(co2Value) + " ppm");
        Serial.println("External fan state: " + String(fan_external_state ? "ON" : "OFF"));
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÄ‡∏ß‡∏•‡∏≤
        bool timeCondition = false;
        if (co2_on_hour < co2_off_hour) {
            timeCondition = (currentHour >= co2_on_hour && currentHour < co2_off_hour);
        } else {
            timeCondition = (currentHour >= co2_on_hour || currentHour < co2_off_hour);
        }
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç CO2 ‡πÅ‡∏•‡∏∞‡∏û‡∏±‡∏î‡∏•‡∏°‡∏£‡∏∞‡∏ö‡∏≤‡∏¢‡∏≠‡∏≤‡∏Å‡∏≤‡∏®
        bool co2Condition = (co2Value < co2_on);
        bool fanNotRunning = !fan_external_state; // CO2 ‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏¥‡∏î‡∏ñ‡πâ‡∏≤‡∏û‡∏±‡∏î‡∏•‡∏°‡∏£‡∏∞‡∏ö‡∏≤‡∏¢‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏¢‡∏π‡πà
        
        if (timeCondition && co2Condition && fanNotRunning) {
            // ‡πÄ‡∏õ‡∏¥‡∏î CO2 (K8 - ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà 7)
            relayCommand.setCharAt(6 + 7, '1');
            co2_state = true;
            Serial.println("Turn ON CO2 (K8) - All conditions met");
        } else if (co2Value > co2_off || !timeCondition || !fanNotRunning) {
            co2_state = false;
            if (!fanNotRunning) {
                Serial.println("Turn OFF CO2 (K8) - External fan is running");
            } else {
                Serial.println("Turn OFF CO2 (K8) - Conditions not met");
            }
        }
    }
    
    // 5. ‡∏ä‡∏∏‡∏î‡∏à‡πà‡∏≤‡∏¢‡∏õ‡∏∏‡πã‡∏¢ A, B (EC Control) -> K7 (‡∏ä‡∏∏‡∏î‡∏à‡πà‡∏≤‡∏¢‡∏™‡∏≤‡∏£‡∏•‡∏∞‡∏•‡∏≤‡∏¢ A,B)
    // 6. ‡∏ä‡∏∏‡∏î‡∏à‡πà‡∏≤‡∏¢‡∏Å‡∏£‡∏î‡πÑ‡∏ô‡∏ï‡∏£‡∏¥‡∏Å (PH Control) -> K6 (‡∏ä‡∏∏‡∏î‡∏à‡πà‡∏≤‡∏¢‡∏Å‡∏£‡∏î‡πÑ‡∏ô‡∏ï‡∏£‡∏¥‡∏Å)
    // 9. ‡∏õ‡∏±‡πä‡∏°‡∏Å‡∏ß‡∏ô‡∏™‡∏≤‡∏£‡∏•‡∏∞‡∏•‡∏≤‡∏¢ -> K5 (‡∏õ‡∏±‡πä‡∏°‡∏ú‡∏™‡∏°‡∏™‡∏≤‡∏£‡∏•‡∏∞‡∏•‡∏≤‡∏¢)
    if (command == "EC_PH") {
        commandProcessed = true;
        if (!doc.containsKey("value") || 
            !doc["value"].containsKey("EC") || 
            !doc["value"].containsKey("KofEC") || 
            !doc["value"].containsKey("PH") || 
            !doc["value"].containsKey("KofPH") || 
            !doc["value"].containsKey("AgitatorPump_delay")) {
            Serial.println("‚ö†Ô∏è Missing required parameters for EC_PH");
            return "";
        }
        
        float targetEC = doc["value"]["EC"];
        float kofEC = doc["value"]["KofEC"];
        float targetPH = doc["value"]["PH"];
        float kofPH = doc["value"]["KofPH"];
        unsigned long agitatorDelay = doc["value"]["AgitatorPump_delay"];
        
        // ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ time_cycle (‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏£‡∏≠‡∏ö)
        static unsigned long lastCycleTime = 0;
        unsigned long time_cycle = 0;
        
        if (doc["value"].containsKey("time_cycle")) {
            time_cycle = doc["value"]["time_cycle"].as<unsigned long>() * 1000; // ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô milliseconds
        }
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ñ‡∏∂‡∏á‡πÄ‡∏ß‡∏•‡∏≤ cycle ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        bool shouldRun = true;
        if (time_cycle > 0) {
            if (currentMillis - lastCycleTime >= time_cycle) {
                lastCycleTime = currentMillis;
                shouldRun = true;
            } else {
                shouldRun = false;
            }
        }
        
        if (shouldRun) {
            Serial.println("EC and PH control (K4-‡∏õ‡∏±‡πä‡∏°‡∏ß‡∏±‡∏î, K5-‡∏õ‡∏±‡πä‡∏°‡∏ú‡∏™‡∏°, K6-‡∏Å‡∏£‡∏î, K7-EC)");
            Serial.println("Target EC: " + String(targetEC) + ", Current EC: " + String(ecValue));
            Serial.println("Target PH: " + String(targetPH) + ", Current PH: " + String(waterPH));
            Serial.println("Agitator delay: " + String(agitatorDelay) + " ms");

            // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î
            float ecError = targetEC - ecValue;
            float phError = targetPH - waterPH;

            // ‡πÄ‡∏õ‡∏¥‡∏î‡∏õ‡∏±‡πä‡∏°‡∏ß‡∏±‡∏î‡∏Ñ‡πà‡∏≤ EC ‡πÅ‡∏•‡∏∞ PH (K4 - ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà 3)
            relayCommand.setCharAt(6 + 3, '1');
            
            // ‡πÄ‡∏õ‡∏¥‡∏î‡∏õ‡∏±‡πä‡∏°‡∏ú‡∏™‡∏°‡∏™‡∏≤‡∏£‡∏•‡∏∞‡∏•‡∏≤‡∏¢ (K5 - ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà 4) - ‡∏õ‡∏±‡πä‡∏°‡∏Å‡∏ß‡∏ô‡∏™‡∏≤‡∏£
            relayCommand.setCharAt(6 + 4, '1');
            agitatorPumpRunning = true;
            agitatorPumpStartTime = currentMillis;
            agitatorPumpDelay = agitatorDelay;
            
            // ‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á‡∏õ‡∏±‡πä‡∏°‡∏Å‡∏ß‡∏ô‡∏™‡∏≤‡∏£
            String pumpTimingCommand = "PUMP_TIMING:AGITATOR," + String(agitatorDelay);
            Serial2.println(pumpTimingCommand);
            Serial.println("Sent agitator pump timing command: " + pumpTimingCommand);

            // 5. ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏õ‡∏±‡πä‡∏° EC (K7 - ‡∏ä‡∏∏‡∏î‡∏à‡πà‡∏≤‡∏¢‡∏™‡∏≤‡∏£‡∏•‡∏∞‡∏•‡∏≤‡∏¢ A,B)
            if (ecError > 0) {
                relayCommand.setCharAt(6 + 6, '1');
                ecPumpRunning = true;
                ecPumpStartTime = currentMillis;
                ecPumpDuration = (unsigned long)(ecError * kofEC * 1000);
                Serial.println("EC is low - Turning ON EC pump (K7) for " + String(ecPumpDuration) + " ms");
                
                String ecPumpCommand = "PUMP_TIMING:EC," + String(ecPumpDuration);
                Serial2.println(ecPumpCommand);
                Serial.println("Sent EC pump timing command: " + ecPumpCommand);
            }

            // 6. ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏õ‡∏±‡πä‡∏° PH (K6 - ‡∏ä‡∏∏‡∏î‡∏à‡πà‡∏≤‡∏¢‡∏Å‡∏£‡∏î‡πÑ‡∏ô‡∏ï‡∏£‡∏¥‡∏Å)
            if (phError != 0) {
                relayCommand.setCharAt(6 + 5, '1');
                phPumpRunning = true;
                phPumpStartTime = currentMillis;
                phPumpDuration = (unsigned long)(abs(phError) * kofPH * 1000);
                Serial.println("PH " + String(phError > 0 ? "low" : "high") + " - Adjusting PH (K6) for " + String(phPumpDuration) + " ms");
                
                String phPumpCommand = "PUMP_TIMING:PH," + String(phPumpDuration);
                Serial2.println(phPumpCommand);
                Serial.println("Sent PH pump timing command: " + phPumpCommand);
            }
        } else {
            Serial.println("Skipping EC/PH control - not at cycle time");
        }
    }
    
    // 7. ‡∏ä‡∏∏‡∏î‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏¢‡πá‡∏ô‡∏™‡∏≤‡∏£‡∏•‡∏∞‡∏•‡∏≤‡∏¢ (Cooling) -> K2 (‡∏ä‡∏∏‡∏î‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏¢‡πá‡∏ô)
    // ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏≠‡∏∏‡∏ì‡∏´‡∏†‡∏π‡∏°‡∏¥‡∏Ç‡∏≠‡∏á‡∏™‡∏≤‡∏£‡∏•‡∏∞‡∏•‡∏≤‡∏¢
    if (command == "Cooling") {
        commandProcessed = true;
        if (!doc.containsKey("value") || !doc["value"].containsKey("on_cooling_when") || 
            !doc["value"].containsKey("off_cooling_when")) {
            Serial.println("‚ö†Ô∏è Missing required parameters for Cooling");
            return "";
        }
        
        float on_cooling_when = doc["value"]["on_cooling_when"];
        float off_cooling_when = doc["value"]["off_cooling_when"];

        Serial.println("Cooling control (K2 - ‡∏ä‡∏∏‡∏î‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏¢‡πá‡∏ô)");
        Serial.println("ON when water temp >= " + String(on_cooling_when) + "¬∞C, OFF when water temp <= " + String(off_cooling_when) + "¬∞C");
        Serial.println("Current water temperature: " + String(waterTemperature) + "¬∞C");

        // ‡πÉ‡∏ä‡πâ‡∏≠‡∏∏‡∏ì‡∏´‡∏†‡∏π‡∏°‡∏¥‡∏Ç‡∏≠‡∏á‡∏™‡∏≤‡∏£‡∏•‡∏∞‡∏•‡∏≤‡∏¢ (waterTemperature) ‡πÅ‡∏ó‡∏ô‡∏≠‡∏∏‡∏ì‡∏´‡∏†‡∏π‡∏°‡∏¥‡∏≠‡∏≤‡∏Å‡∏≤‡∏®
        if (waterTemperature >= on_cooling_when) {
            relayCommand.setCharAt(6 + 1, '1');
            cooling_pump_state = true;
            Serial.println("Turn ON cooling system (K2) - Water temperature control");
        } else if (waterTemperature <= off_cooling_when) {
            cooling_pump_state = false;
            Serial.println("Turn OFF cooling system (K2)");
        }
    }
    
    // 8. ‡∏õ‡∏±‡πä‡∏°‡∏™‡∏≤‡∏£‡∏•‡∏∞‡∏•‡∏≤‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô‡∏£‡∏≤‡∏á‡∏õ‡∏•‡∏π‡∏Å - ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÑ‡∏´‡∏•‡∏Ç‡∏≠‡∏á‡∏™‡∏≤‡∏£‡∏•‡∏∞‡∏•‡∏≤‡∏¢
    if (command == "circulation_pump") {
        commandProcessed = true;
        Serial.println("Circulation pump control - Always ON with flow monitoring");
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÑ‡∏´‡∏•‡∏Ç‡∏≠‡∏á‡∏™‡∏≤‡∏£‡∏•‡∏∞‡∏•‡∏≤‡∏¢ (‡πÉ‡∏ä‡πâ flow sensor)
        if (flowRate1 <= 0.1) { // ‡∏ñ‡πâ‡∏≤‡∏≠‡∏±‡∏ï‡∏£‡∏≤‡∏Å‡∏≤‡∏£‡πÑ‡∏´‡∏•‡∏ï‡πà‡∏≥‡∏°‡∏≤‡∏Å
            Serial.println("‚ö†Ô∏è WARNING: Low flow rate detected! Flow rate: " + String(flowRate1) + " L/min");
            // ‡∏™‡πà‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô
            String alertCommand = "FLOW_ALERT:LOW_FLOW," + String(flowRate1);
            Serial2.println(alertCommand);
        } else {
            Serial.println("‚úÖ Flow rate normal: " + String(flowRate1) + " L/min");
        }
        
        // ‡∏õ‡∏±‡πä‡∏°‡πÄ‡∏õ‡∏¥‡∏î‡∏ï‡∏•‡∏≠‡∏î‡πÄ‡∏ß‡∏•‡∏≤ (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ relay ‡πÅ‡∏ï‡πà‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡πÅ‡∏¢‡∏Å)
        String pumpCommand = "CIRCULATION_PUMP:ON";
        Serial2.println(pumpCommand);
        Serial.println("Circulation pump: Always ON");
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏ô‡πâ‡∏≥ (Water Level Check)
    if (command == "water_level_check") {
        commandProcessed = true;
        Serial.println("Water level monitoring");
        Serial.println("Current water level: " + String(waterLevel) + "%");
        
        if (waterLevel < 20) {
            Serial.println("‚ö†Ô∏è WARNING: Low water level! Level: " + String(waterLevel) + "%");
            // ‡∏™‡πà‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô
            String alertCommand = "WATER_ALERT:LOW_LEVEL," + String(waterLevel);
            Serial2.println(alertCommand);
        } else if (waterLevel > 90) {
            Serial.println("‚ö†Ô∏è WARNING: High water level! Level: " + String(waterLevel) + "%");
            String alertCommand = "WATER_ALERT:HIGH_LEVEL," + String(waterLevel);
            Serial2.println(alertCommand);
        } else {
            Serial.println("‚úÖ Water level normal: " + String(waterLevel) + "%");
        }
    }
    
    // ‡∏£‡∏ß‡∏°‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÑ‡∏ü‡πÅ‡∏•‡∏∞ CO2 (‡πÄ‡∏î‡∏¥‡∏° - ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏±‡∏ô‡πÑ‡∏î‡πâ)
    if (command == "light_co2") {
        commandProcessed = true;
        if (!doc.containsKey("value") || !doc["value"].containsKey("on") || 
            !doc["value"].containsKey("off") || !doc["value"].containsKey("co2_on") || 
            !doc["value"].containsKey("co2_off")) {
            Serial.println("‚ö†Ô∏è Missing required parameters for light_co2");
            return "";
        }
        
        int light_on = doc["value"]["on"];
        int light_off = doc["value"]["off"];
        int co2_on = doc["value"]["co2_on"];
        int co2_off = doc["value"]["co2_off"];
        unsigned long currentHour = (unixTimestamp / 3600) % 24;

        Serial.println("Light and CO2 control (K1-‡πÑ‡∏ü, K8-CO2)");
        Serial.println("Light ON: " + String(light_on) + ", Light OFF: " + String(light_off));
        Serial.println("CO2 ON when <= " + String(co2_on) + ", CO2 OFF when >= " + String(co2_off));
        Serial.println("Current hour: " + String(currentHour) + ", Current CO2: " + String(co2Value));
        Serial.println("Current light level: " + String(lightValue) + " lux");
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÅ‡∏™‡∏á‡πÅ‡∏•‡∏∞ CO2
        bool lightShouldBeOn = false;
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÑ‡∏ü
        if (light_on < light_off) {
            lightShouldBeOn = (currentHour >= light_on && currentHour < light_off);
        } else {
            lightShouldBeOn = (currentHour >= light_on || currentHour < light_off);
        }
        // Serial.println("lightShouldBeOn: " + lightShouldBeOn);
        // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ß‡πà‡∏≤‡∏á (‡∏ñ‡πâ‡∏≤‡πÅ‡∏™‡∏á‡∏ò‡∏£‡∏£‡∏°‡∏ä‡∏≤‡∏ï‡∏¥‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠‡∏Å‡πá‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏ü)
        bool needMoreLight = (lightValue < 100); // ‡∏ñ‡πâ‡∏≤‡πÅ‡∏™‡∏á‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤ 10,000 lux
      
        // if (lightShouldBeOn && needMoreLight) {
              if (lightShouldBeOn && true) {
            relayCommand.setCharAt(6 + 0, '1');
            light_state = true;
            Serial.println("Turn ON light (K1) - Time & Light conditions");
            
            // ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏° CO2 ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡∏∞‡∏û‡∏±‡∏î‡∏•‡∏°‡∏£‡∏∞‡∏ö‡∏≤‡∏¢‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡∏õ‡∏¥‡∏î
            if (co2Value <= co2_on && !fan_external_state) {
                relayCommand.setCharAt(6 + 7, '1');
                co2_state = true;
                Serial.println("Turn ON CO2 (K8)");
            } else if (co2Value >= co2_off || fan_external_state) {
                co2_state = false;
                if (fan_external_state) {
                    Serial.println("Turn OFF CO2 (K8) - External fan running");
                } else {
                    Serial.println("Turn OFF CO2 (K8) - CO2 level sufficient");
                }
            }
       
        } else {
            light_state = false;
            co2_state = false;
            if (!needMoreLight) {
                Serial.println("Turn OFF light (K1) - Natural light sufficient");
            } else {
                Serial.println("Turn OFF light (K1) and CO2 (K8) - Outside time range");
            }
        }
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ñ‡∏π‡∏Å‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if (!commandProcessed) {
        Serial.println("‚ö†Ô∏è Unknown command: " + command);
        return "";
    }
    
    return relayCommand;
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô callback ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö BeeNeXT
void beeNeXTCallback(String topic, String message) {
    // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏õ‡πÅ‡∏™‡∏î‡∏á‡∏ö‡∏ô‡∏à‡∏≠ BeeNeXT
    if (topic == "cabinets/cab_tok_001/data") {
        // ‡πÅ‡∏õ‡∏•‡∏á JSON message
        StaticJsonDocument<512> displayDoc;
        DeserializationError error = deserializeJson(displayDoc, message);
        
        if (!error) {
            String sensorName = displayDoc["sensor"].as<String>();
            String cabinetId = displayDoc["cabinet_id"].as<String>();
            unsigned long timestamp = displayDoc["timestamp"].as<unsigned long>();
            
            // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏õ‡πÅ‡∏™‡∏î‡∏á‡∏ö‡∏ô‡∏à‡∏≠‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå
            if (sensorName == "CO2") {
                float value = displayDoc["value"].as<float>();
                LCD.publish("/myBeeNeXT/CO2", String(value));
            }
            else if (sensorName == "Light") {
                float value = displayDoc["value"].as<float>();
                LCD.publish("/myBeeNeXT/LIGHT", String(value));
            }
            else if (sensorName == "EC") {
                float value = displayDoc["value"].as<float>();
                LCD.publish("/myBeeNeXT/EC", String(value));
            }
            else if (sensorName == "Water_Level") {
                float value = displayDoc["value"].as<float>();
                LCD.publish("/myBeeNeXT/WATER_LEVEL", String(value));
            }
            else if (sensorName == "Air_Humidity_Temperature") {
                JsonObject valueObj = displayDoc["value"].as<JsonObject>();
                float humidity = valueObj["humidity"];
                float temperature = valueObj["temperature"];
                LCD.publish("/myBeeNeXT/AIR_TEMP", String(temperature));
                LCD.publish("/myBeeNeXT/AIR_HUMIDITY", String(humidity));
            }
            else if (sensorName == "Water_Temp_PH") {
                JsonObject valueObj = displayDoc["value"].as<JsonObject>();
                float waterTemp = valueObj["temperature"];
                float ph = valueObj["ph"];
                LCD.publish("/myBeeNeXT/WATER_TEMP", String(waterTemp));
                LCD.publish("/myBeeNeXT/PH", String(ph));
            }
            else if (sensorName == "PowerMeter") {
                JsonObject valueObj = displayDoc["value"].as<JsonObject>();
                float voltage = valueObj["voltage"];
                float current = valueObj["current"];
                float power = valueObj["power"];
                LCD.publish("/myBeeNeXT/VOLTAGE", String(voltage));
                LCD.publish("/myBeeNeXT/CURRENT", String(current));
                LCD.publish("/myBeeNeXT/POWER", String(power));
            }
        }
    }
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏´‡∏•‡∏≤‡∏¢‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô
String processMultipleCommands(JsonDocument& doc) {
    String relayCommand = "RELAY:00000000";
    bool hasAnyCommand = false;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô array ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if (doc.containsKey("commands") && doc["commands"].is<JsonArray>()) {
        JsonArray commands = doc["commands"].as<JsonArray>();
        Serial.println("üîÑ Processing " + String(commands.size()) + " commands simultaneously");
        
        for (JsonVariant commandVar : commands) {
            if (commandVar.is<JsonObject>()) {
                JsonObject commandObj = commandVar.as<JsonObject>();
                
                // ‡∏™‡∏£‡πâ‡∏≤‡∏á temporary document ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á
                DynamicJsonDocument tempDoc(2048);
                tempDoc.set(commandObj);
                
                // ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ï‡∏±‡∏ß
                String singleRelayCommand = convertJsonToRelayCommand(tempDoc);
                
                if (singleRelayCommand != "") {
                    hasAnyCommand = true;
                    // ‡∏£‡∏ß‡∏° relay commands ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ OR operation
                    for (int i = 0; i < 8; i++) {
                        if (singleRelayCommand.charAt(6 + i) == '1') {
                            relayCommand.setCharAt(6 + i, '1');
                        }
                    }
                }
            }
        }
        
        if (hasAnyCommand) {
            Serial.println("üîó Combined relay command: " + relayCommand);
            return relayCommand;
        }
    }
    
    return "";
}

void callback(char* topic, byte* payload, unsigned int length) {
    // ‡πÅ‡∏õ‡∏•‡∏á payload ‡πÄ‡∏õ‡πá‡∏ô String
    String receivedMessage = "";
    for (unsigned int i = 0; i < length; i++) {
        receivedMessage += (char)payload[i];
    }

    // ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏ì‡∏µ timesync
    if (strcmp(topic, "timesync2") == 0) {
        DynamicJsonDocument timeDoc(256);
        DeserializationError error = deserializeJson(timeDoc, payload);
        if (error) {
            return;
        }

        if (timeDoc.containsKey("unixTimestamp")) {
            unixTimestamp = timeDoc["unixTimestamp"].as<unsigned long>();
            Serial.println("‚è∞ Received timestamp: " + String(unixTimestamp));
        }

        if (timeDoc.containsKey("timeOnly")) {
            String timeOnlyStr = timeDoc["timeOnly"].as<String>();
            // ‡πÅ‡∏õ‡∏•‡∏á "16:00:11" ‡πÉ‡∏´‡πâ‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÅ‡∏Ñ‡πà 16
            int colonIndex = timeOnlyStr.indexOf(':');
            if (colonIndex > 0) {
                String hourStr = timeOnlyStr.substring(0, colonIndex);
                timeOnly = hourStr.toInt();
                Serial.println("‚è∞ Received time only hour: " + String(timeOnly));
            }
        }
        return;
    }

    // ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö BeeNeXT Display
    char beeNeXTDataTopic[64];
    sprintf(beeNeXTDataTopic, "cabinets/%s/data", cabinetId);
    if (strcmp(topic, beeNeXTDataTopic) == 0) {
        beeNeXTCallback(String(topic), receivedMessage);
        return;
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô topic control ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if (strcmp(topic, topic_control) != 0) {
        return;
    }

    Serial.println("‚úÖ Processing control command from correct topic: " + String(topic_control));

    // Parse JSON ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°
    DeserializationError error = deserializeJson(doc, payload);
    if (error) {
        Serial.println("‚ö†Ô∏è Failed to parse JSON: " + String(error.f_str()));
        return;
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏•‡∏≤‡∏¢‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if (doc.containsKey("commands") && doc["commands"].is<JsonArray>()) {
        Serial.println("üéØ Processing multiple commands simultaneously");
        
        // ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏´‡∏•‡∏≤‡∏¢‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô
        String multiRelayCommand = processMultipleCommands(doc);
        
        if (multiRelayCommand != "") {
            Serial2.println(multiRelayCommand);
            Serial.println("üîÅ Sent combined relay command to Arduino Mega: " + multiRelayCommand);
        }
        
        // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á
        JsonArray commands = doc["commands"].as<JsonArray>();
        for (JsonVariant commandVar : commands) {
            if (commandVar.is<JsonObject>()) {
                JsonObject commandObj = commandVar.as<JsonObject>();
                DynamicJsonDocument tempDoc(2048);
                tempDoc.set(commandObj);
                updateControlSettings(tempDoc);
            }
        }
        
        Serial.println("üîÑ Multiple control settings updated. System will execute continuously.");
        return;
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ command ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß)
    if (!doc.containsKey("command")) {
        Serial.println("‚ö†Ô∏è JSON ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏µ‡∏¢‡πå 'command' ‡∏´‡∏£‡∏∑‡∏≠ 'commands'");
        return;
    }

    String command = doc["command"].as<String>();
    Serial.println("üéØ Processing command: " + command);

    // ‡∏Å‡∏£‡∏ì‡∏µ‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏° relay ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
    if (command == "relay_control") {
        Serial.println("üîÅ Received relay control command");
        
        // ‡∏™‡∏£‡πâ‡∏≤‡∏á String ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö relay ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏™‡πà‡∏á JSON ‡∏ï‡∏£‡∏á‡πÑ‡∏õ
        String relayCommand = "RELAY:";
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• relays ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        if (doc.containsKey("relays") && doc["relays"].is<JsonArray>()) {
            JsonArray relays = doc["relays"].as<JsonArray>();
            
            for (int i = 0; i < 8 && i < relays.size(); i++) {
                int state = relays[i];
                relayCommand += String(state);
            }
            
            // ‡πÄ‡∏ï‡∏¥‡∏° 0 ‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö 8 ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ñ‡πâ‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö
            while (relayCommand.length() < 14) { // "RELAY:" + 8 digits = 14 chars
                relayCommand += "0";
            }
            
            // ‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á String ‡πÑ‡∏õ‡∏¢‡∏±‡∏á Arduino Mega
            Serial2.println(relayCommand);
            Serial.println("üîÅ Sent relay command to Arduino Mega: " + relayCommand);
        } else {
            Serial.println("‚ö†Ô∏è relay_control command missing 'relays' array");
        }
        return;
    }

    // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏à‡∏≤‡∏Å‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á MQTT (‡∏£‡∏∞‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà) - ‡∏•‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å convertJsonToRelayCommand ‡∏≠‡∏≠‡∏Å
    updateControlSettings(doc);
    
    // ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏à‡∏≤‡∏Å MQTT ‡∏ú‡πà‡∏≤‡∏ô executeControlLogic()
    Serial.println("üîÑ Control settings updated. System will execute continuously.");
}
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Arduino Mega
void requestDataFromMega() {
    if (millis() - lastDataRequestTime >= dataRequestInterval && megaConnected) {
        lastDataRequestTime = millis();
        Serial2.println("DATA_REQUEST");
    }
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Arduino Mega
void receiveDataFromMega() {
    if (Serial2.available() > 0) {
        String inputString = Serial2.readStringUntil('\n');
        inputString.trim(); // ‡∏ï‡∏±‡∏î‡∏ä‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡∏Ç‡∏∂‡πâ‡∏ô‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏¥‡πâ‡∏á
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏õ‡πá‡∏ô JSON ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        if (inputString.startsWith("{")) {
            // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏ô‡∏≤‡∏î JSON Document ‡πÄ‡∏õ‡πá‡∏ô 1024 bytes
            StaticJsonDocument<1024> jsonDoc;
            DeserializationError error = deserializeJson(jsonDoc, inputString);
            
            if (error) {
                // ‡∏™‡πà‡∏á‡∏Å‡∏≤‡∏£‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡πÅ‡∏°‡πâ‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î (‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ Mega ‡∏£‡∏≠‡∏ô‡∏≤‡∏ô)
                Serial2.println("JSON_ERROR");
                return;
            }
            
            // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡πÅ‡∏•‡∏∞‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
            lastMegaComm = millis();
            megaConnected = true;
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
            if (jsonDoc.containsKey("msgType") && jsonDoc["msgType"] == "SENSOR_DATA") {
                // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏•‡∏á‡πÉ‡∏ô‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£
                if (jsonDoc.containsKey("co2")) {
                    co2Value = jsonDoc["co2"].as<int>();
                }
                
                if (jsonDoc.containsKey("airTemp")) {
                    airTemperature = jsonDoc["airTemp"].as<float>();
                }
                
                if (jsonDoc.containsKey("airHumidity")) {
                    airHumidity = jsonDoc["airHumidity"].as<float>();
                }
                
                if (jsonDoc.containsKey("light")) {
                    lightValue = jsonDoc["light"].as<unsigned long>();
                }
                
                if (jsonDoc.containsKey("ec")) {
                    ecValue = jsonDoc["ec"].as<float>();
                }
                
                if (jsonDoc.containsKey("ph")) {
                    waterPH = jsonDoc["ph"].as<float>();
                }
                
                if (jsonDoc.containsKey("waterTemp")) {
                    waterTemperature = jsonDoc["waterTemp"].as<float>();
                }
                
                if (jsonDoc.containsKey("waterLevel")) {
                    waterLevel = jsonDoc["waterLevel"].as<int>();
                }
                
                // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå AC Power
                if (jsonDoc.containsKey("acVoltage")) {
                    voltage = jsonDoc["acVoltage"].as<float>();
                }
                
                if (jsonDoc.containsKey("acCurrent")) {
                    current = jsonDoc["acCurrent"].as<float>();
                }
                
                if (jsonDoc.containsKey("acPower")) {
                    power = jsonDoc["acPower"].as<float>();
                }
                
                if (jsonDoc.containsKey("acEnergy")) {
                    energy = jsonDoc["acEnergy"].as<float>();
                }
                
                if (jsonDoc.containsKey("acFrequency")) {
                    frequency = jsonDoc["acFrequency"].as<float>();
                }
                
                if (jsonDoc.containsKey("acPowerFactor")) {
                    pf = jsonDoc["acPowerFactor"].as<float>();
                }

                //‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏≠‡∏±‡∏ï‡∏£‡∏≤‡∏Å‡∏≤‡∏£‡πÑ‡∏´‡∏•‡∏Ç‡∏≠‡∏á‡∏ô‡πâ‡∏≥
                if (jsonDoc.containsKey("flowSensor1_LPM")) {
                    flowRate1 = jsonDoc["flowSensor1_LPM"].as<float>();
                }
                
                if (jsonDoc.containsKey("flowSensor2_LPM")) {
                    flowRate2 = jsonDoc["flowSensor2_LPM"].as<float>();
                }
                
                if (jsonDoc.containsKey("flowSensor3_LPM")) {
                    flowRate3 = jsonDoc["flowSensor3_LPM"].as<float>();
                }

                if (jsonDoc.containsKey("flowSensor1_Liters")) {
                    totalLiters1 = jsonDoc["flowSensor1_Liters"].as<float>();
                }
                
                if (jsonDoc.containsKey("flowSensor2_Liters")) {
                    totalLiters2 = jsonDoc["flowSensor2_Liters"].as<float>();
                }
                
                if (jsonDoc.containsKey("flowSensor3_Liters")) {
                    totalLiters3 = jsonDoc["flowSensor3_Liters"].as<float>();
                }

                hasNewSensorData = true;  // ‡∏ó‡∏≥‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà
                
                // ‡∏™‡πà‡∏á‡∏Å‡∏≤‡∏£‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏¢‡∏±‡∏á Arduino Mega
                Serial2.println("DATA_RECEIVED");
                
            } else {
                Serial2.println("UNKNOWN_MSG_TYPE");
            }
        } 
        // ‡πÉ‡∏ä‡πâ indexOf ‡πÅ‡∏ó‡∏ô == ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏°‡∏µ "MEGA_TEST" ‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        else if (inputString.indexOf("MEGA_TEST") >= 0) {
            // ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
            Serial2.println("ESP32_OK");
            lastMegaComm = millis();
            megaConnected = true;
        } else {
            Serial2.println("INVALID_FORMAT");
        }
    }
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö Arduino Mega
void checkMegaConnection() {
    // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Mega ‡πÄ‡∏Å‡∏¥‡∏ô 30 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ ‡πÉ‡∏´‡πâ‡∏ñ‡∏∑‡∏≠‡∏ß‡πà‡∏≤‡∏Ç‡∏≤‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
    if (millis() - lastMegaComm > 30000) {
        if (megaConnected) {
            megaConnected = false;
        }
        
        // ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏∏‡∏Å 5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
        static unsigned long lastTestTime = 0;
        if (millis() - lastTestTime > 5000) {
            lastTestTime = millis();
            Serial2.println("ESP32_TEST");
        }
    }
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ú‡πà‡∏≤‡∏ô MQTT (‡πÄ‡∏£‡πá‡∏ß‡∏°‡∏≤‡∏Å)
void publishAllSensorData() {
    if (unixTimestamp == 0) {
        return;
    }
    
    if (!client.connected()) {
        return;
    }
    
    // ‡∏™‡πà‡∏á Water Level ‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏™‡∏ô‡πÉ‡∏à‡∏Ñ‡πà‡∏≤
    publishSensorData("Water_Level", waterLevel);
    
    // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏£‡∏ß‡∏î‡πÄ‡∏£‡πá‡∏ß (‡∏•‡∏ö debug messages ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß)
    publishSensorData("CO2", co2Value);
    delay(5);
  
    publishSensorData("Light", lightValue);
    delay(5);
  
    publishSensorData("EC", ecValue);
    delay(5);
  
    // Air Humidity & Temperature
    StaticJsonDocument<256> airDoc;
    JsonObject airData = airDoc.to<JsonObject>();
    airData["humidity"] = airHumidity;
    airData["temperature"] = airTemperature;
    publishSensorDataObject("Air_Humidity_Temperature", airData);
    delay(5);
  
    // Water Temp & PH
    StaticJsonDocument<256> waterDoc;
    JsonObject waterData = waterDoc.to<JsonObject>();
    waterData["temperature"] = waterTemperature;
    waterData["ph"] = waterPH;
    publishSensorDataObject("Water_Temp_PH", waterData);
    delay(5);
  
    // Power Meter
    StaticJsonDocument<256> powerDoc;
    JsonObject powerData = powerDoc.to<JsonObject>();
    powerData["voltage"] = voltage;
    powerData["current"] = current;
    powerData["power"] = power;
    powerData["energy"] = energy;
    powerData["frequency"] = frequency;
    powerData["pf"] = pf;
    publishSensorDataObject("PowerMeter", powerData);
    delay(5);
  
    // Flow Sensors
    publishSensorData("FlowSensor1_LPM", flowRate1);
    delay(5);
    publishSensorData("FlowSensor2_LPM", flowRate2);
    delay(5);
    publishSensorData("FlowSensor3_LPM", flowRate3);
    delay(5);

    publishSensorData("FlowSensor1_Liters", totalLiters1);
    delay(5);
    publishSensorData("FlowSensor2_Liters", totalLiters2);
    delay(5);
    publishSensorData("FlowSensor3_Liters", totalLiters3);
    delay(5);
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô printSystemStatus ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏∞‡∏¢‡∏∞
void printSystemStatus() {
    // Function removed - not related to control commands
}

// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Batch Processing (‡πÅ‡∏ö‡∏ö‡∏á‡πà‡∏≤‡∏¢)
struct SimpleBatch {
    String commands[20]; // ‡πÄ‡∏Å‡πá‡∏ö JSON string
    int count;
    unsigned long lastBatchTime;
} commandBatch;

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÄ‡∏Ç‡πâ‡∏≤ batch
void addCommandToBatch(String jsonString) {
    if (commandBatch.count < 20) {
        commandBatch.commands[commandBatch.count] = jsonString;
        commandBatch.count++;
        commandBatch.lastBatchTime = millis();
    }
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• batch commands
void processBatchCommands() {
    // ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• batch ‡∏ó‡∏∏‡∏Å 2 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏°‡∏∑‡πà‡∏≠ batch ‡πÄ‡∏ï‡πá‡∏°
    if (commandBatch.count > 0 && 
        (millis() - commandBatch.lastBatchTime > 2000 || commandBatch.count >= 20)) {
        
        Serial.println("üîÑ Processing batch of " + String(commandBatch.count) + " commands");
        
        // ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô batch
        for (int i = 0; i < commandBatch.count; i++) {
            DynamicJsonDocument tempDoc(2048);
            DeserializationError error = deserializeJson(tempDoc, commandBatch.commands[i]);
            if (!error) {
                updateControlSettings(tempDoc);
            }
        }
        
        // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï batch
        commandBatch.count = 0;
        commandBatch.lastBatchTime = millis();
        
        Serial.println("‚úÖ Batch processing completed");
    }
}

void setup() {
    Serial.begin(115200);  // ‡πÄ‡∏£‡∏¥‡πà‡∏° Serial Monitor
    delay(1000);
    
    // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
    Serial.println("\n\n=================================");
    Serial.println("ESP32-S3-DevKitC-1 Hydroponics System");
    Serial.println("with BeeNeXT Display Integration");
    Serial.println("=================================");
    
    // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Serial2 ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏™‡∏∑‡πà‡∏≠‡∏™‡∏≤‡∏£‡∏Å‡∏±‡∏ö Arduino Mega ‡πÇ‡∏î‡∏¢‡∏£‡∏∞‡∏ö‡∏∏‡∏Ç‡∏≤ RX, TX ‡πÉ‡∏´‡πâ‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô
    Serial2.begin(115200, SERIAL_8N1, RXD2, TXD2);  // RX=18, TX=17 (‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÑ‡∏ß‡πâ‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô)

    // ‡∏•‡πâ‡∏≤‡∏á buffer ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
    while (Serial2.available() > 0) {
        Serial2.read();
    }

    // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Pin ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå (‡∏™‡∏≥‡∏£‡∏≠‡∏á‡πÑ‡∏ß‡πâ - ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô)
    // *** ‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏: ‡∏£‡∏∞‡∏ö‡∏ö‡πÉ‡∏ä‡πâ relay ‡∏ú‡πà‡∏≤‡∏ô Arduino Mega ‡πÅ‡∏ó‡∏ô ***
    pinMode(fan_internal_pin, OUTPUT);
    pinMode(fan_external_pin, OUTPUT);
    pinMode(light_pin, OUTPUT);
    pinMode(co2_pin, OUTPUT);
    pinMode(agitatorPumpPin, OUTPUT); // ‡∏õ‡∏±‡πä‡∏°‡∏Å‡∏ß‡∏ô‡∏™‡∏≤‡∏£
    pinMode(ecPumpPin, OUTPUT);       // ‡∏õ‡∏±‡πä‡∏° EC
    pinMode(phPumpPin, OUTPUT);       // ‡∏õ‡∏±‡πä‡∏° PH
    pinMode(cooling_pump_pin, OUTPUT); // ‡∏õ‡∏±‡πä‡∏°‡∏ô‡πâ‡∏≥‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏¢‡πá‡∏ô (‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà)

    // ‡∏õ‡∏¥‡∏î‡∏ó‡∏∏‡∏Å‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô (‡∏™‡∏≥‡∏£‡∏≠‡∏á‡πÑ‡∏ß‡πâ - ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô)
    digitalWrite(fan_internal_pin, LOW);
    digitalWrite(fan_external_pin, LOW);
    digitalWrite(light_pin, LOW);
    digitalWrite(co2_pin, LOW);
    digitalWrite(agitatorPumpPin, LOW);
    digitalWrite(ecPumpPin, LOW);
    digitalWrite(phPumpPin, LOW);
    digitalWrite(cooling_pump_pin, LOW);

    // Initialize BeeNeXT Display
    LCD.begin(mqtt_server, mqtt_port, mqtt_username, mqtt_password, beeNeXTCallback);
    
    // ‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏: BeeNeXT library ‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á debug messages ‡∏Ç‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á
    // ‡∏ã‡∏∂‡πà‡∏á‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏õ‡∏¥‡∏î‡πÑ‡∏î‡πâ‡∏à‡∏≤‡∏Å‡πÇ‡∏Ñ‡πâ‡∏î‡∏ô‡∏µ‡πâ
    
    // Subscribe BeeNeXT topics to receive data from our own sensor publishing
    char beeNeXTDataTopic[64];
    sprintf(beeNeXTDataTopic, "cabinets/%s/data", cabinetId);
    LCD.subscribe(beeNeXTDataTopic);
    
    beeNeXTConnected = true;

    // ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ WiFi ‡πÅ‡∏ö‡∏ö‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏∑‡∏ö‡∏´‡∏ô‡πâ‡∏≤
    WiFi.mode(WIFI_STA);
    WiFi.begin(ssid, password);
    
    // ‡∏£‡∏≠‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ WiFi ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÅ‡∏™‡∏î‡∏á‡∏à‡∏∏‡∏î
    unsigned long wifiStartTime = millis();
    while (WiFi.status() != WL_CONNECTED && millis() - wifiStartTime < 30000) {
        delay(500);
        Serial.print(".");
    }
    Serial.println();
    
    if (WiFi.status() == WL_CONNECTED) {
        Serial.println("‚úÖ WiFi Connected!");
        Serial.println("IP Address: " + WiFi.localIP().toString());
    }

    // ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö Arduino Mega
    for (int i = 0; i < 3; i++) {  // ‡∏•‡∏≠‡∏á‡∏ó‡∏î‡∏™‡∏≠‡∏ö 3 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á
        Serial2.println("ESP32_TEST");
        
        // ‡∏£‡∏≠‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
        unsigned long startTime = millis();
        while (millis() - startTime < 1000) {
            if (Serial2.available() > 0) {
                String response = Serial2.readStringUntil('\n');
                if (response.indexOf("MEGA_OK") >= 0) {
                    Serial.println("‚úÖ Arduino Mega Connected!");
                    megaConnected = true;
                    lastMegaComm = millis();
                    break;
                }
            }
            delay(10);
        }
        
        if (megaConnected) {
            break;
        }
        
        delay(1000);
    }

    // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ MQTT
    client.setServer(mqtt_server, mqtt_port);
    client.setCallback(callback);
    
    // ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MQTT ‡∏ñ‡πâ‡∏≤ WiFi ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÅ‡∏•‡πâ‡∏ß
    if (WiFi.status() == WL_CONNECTED) {
        connectToMQTT();
    }
    
    Serial.println("\nüöÄ System Ready - Monitoring MQTT Control Commands");
}

void loop() {
    currentMillis = millis();  // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡πÄ‡∏ß‡∏•‡∏≤‡πÉ‡∏ô‡∏Ç‡∏ì‡∏∞‡∏ô‡∏µ‡πâ

    // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó BeeNeXT (‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏°‡∏≤‡∏Å!)
    BeeNeXT.update();
    
    // ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö WiFi ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
    if (WiFi.status() != WL_CONNECTED) {
        static unsigned long lastWiFiRetry = 0;
        if (currentMillis - lastWiFiRetry >= 30000) { // ‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ WiFi ‡∏ó‡∏∏‡∏Å 30 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
            lastWiFiRetry = currentMillis;
            WiFi.begin(ssid, password);
        }
    } 
    
    // ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö MQTT ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ ‡πÅ‡∏•‡∏∞ WiFi ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÅ‡∏•‡πâ‡∏ß
    if (WiFi.status() == WL_CONNECTED && !client.connected()) {
        static unsigned long lastReconnectAttempt = 0;
        if (currentMillis - lastReconnectAttempt >= mqttReconnectInterval) {
            lastReconnectAttempt = currentMillis;
            connectToMQTT();
        }
    }
    
    // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô loop() ‡∏ö‡πà‡∏≠‡∏¢‡πÜ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏±‡∏ö MQTT messages
    if (client.connected()) {
        client.loop();
    }
    
    // ‡∏£‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Arduino Mega ‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏∞‡∏¢‡∏∞ (‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ)
    requestDataFromMega();
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Arduino Mega ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if (currentMillis - lastMegaDataCheckTime >= megaDataCheckInterval) {
        lastMegaDataCheckTime = currentMillis;
        receiveDataFromMega();
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö Arduino Mega
    checkMegaConnection();

    // ‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å MQTT (‡∏£‡∏∞‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà)
    executeControlLogic();

    // ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• batch commands
    processBatchCommands();

    // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÄ‡∏£‡πá‡∏ß‡∏°‡∏≤‡∏Å ‡∏ó‡∏∏‡∏Å‡πÜ 200ms ‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏≠‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà
    if (currentMillis - lastSensorPublishTime >= sensorPublishInterval && client.connected() && unixTimestamp != 0) {
        lastSensorPublishTime = currentMillis;
        publishAllSensorData();
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ç‡∏≠‡∏á‡∏õ‡∏±‡πä‡∏°‡∏Å‡∏ß‡∏ô‡∏™‡∏≤‡∏£ (non-blocking)
    if (agitatorPumpRunning && (currentMillis - agitatorPumpStartTime >= agitatorPumpDelay)) {
        digitalWrite(agitatorPumpPin, LOW);  // ‡∏õ‡∏¥‡∏î‡∏õ‡∏±‡πä‡∏°‡∏Å‡∏ß‡∏ô‡∏™‡∏≤‡∏£
        agitatorPumpRunning = false;  // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ß‡πà‡∏≤‡∏õ‡∏±‡πä‡∏°‡∏´‡∏¢‡∏∏‡∏î‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
        unsigned long runTime = currentMillis - agitatorPumpStartTime;
        Serial.println("Stop Agitator Pump after (ms): " + String(runTime));
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ç‡∏≠‡∏á‡∏õ‡∏±‡πä‡∏° EC (non-blocking)
    if (ecPumpRunning && (currentMillis - ecPumpStartTime >= ecPumpDuration)) {
        digitalWrite(ecPumpPin, LOW);  // ‡∏õ‡∏¥‡∏î‡∏õ‡∏±‡πä‡∏° EC
        ecPumpRunning = false;  // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ß‡πà‡∏≤‡∏õ‡∏±‡πä‡∏°‡∏´‡∏¢‡∏∏‡∏î‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
        unsigned long runTime = currentMillis - ecPumpStartTime;
        Serial.println("Stop EC Pump after (ms): " + String(runTime));
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ç‡∏≠‡∏á‡∏õ‡∏±‡πä‡∏° PH (non-blocking)
    if (phPumpRunning && (currentMillis - phPumpStartTime >= phPumpDuration)) {
        digitalWrite(phPumpPin, LOW);  // ‡∏õ‡∏¥‡∏î‡∏õ‡∏±‡πä‡∏° PH
        phPumpRunning = false;  // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ß‡πà‡∏≤‡∏õ‡∏±‡πä‡∏°‡∏´‡∏¢‡∏∏‡∏î‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
        unsigned long runTime = currentMillis - phPumpStartTime;
        Serial.println("Stop PH Pump after (ms): " + String(runTime));
    }
    
    // ‡∏´‡∏ô‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ CPU ‡πÑ‡∏î‡πâ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏≠‡∏∑‡πà‡∏ô (‡∏•‡∏î‡∏•‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß)
    delay(1);
}

